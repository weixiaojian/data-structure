# 树结构
> 将数据使用数结构储存后 查找十分搞笑  
> 常见的树结构：二分搜索树、平衡二叉树（AVL）、红黑树、堆、并查集、线段树、Trie（字段树、前缀树）

# 二叉树
* 二叉树具有天然递归结构
* 每一个节点的左子树也是二叉树、每一个节点的右子节点也是二叉树
```
public class Node<E> {

    E e;
    Node left;
    Node right;

}
```

# 二分搜索树
* 二分搜索树是二叉树
* 每个节点的值要大于其左子节点的所有值，每个节点的值小于其右子节点的所有的值
* 每一个字树也是二分搜索树
* 储存的元素必须有可比较性
```
public class BST<E extends Comparable<E>> {

    private Node root;
    private int size;

    public BST() {
        this.root = null;
        this.size = 0;
    }

    /**
     * 向二分搜索树中添加元素
     * @param e
     */
    public void add(E e) {
        root = addByRecursive(root, e);
    }

    /**
     * 在二分搜索树中查找指定元素
     * @param e
     * @return
     */
    public boolean contains(E e){
        return containsByRecursive(root, e);
    }


    /**
     * 递归的向node中添加元素e
     * 返回插入新节点后二分搜索树的根
     * @param node
     * @param e
     */
    private Node addByRecursive(Node node, E e) {
        if (node == null) {
            size++;
            return new Node(e);
        }
        if (e.compareTo((E) node.e) < 0) {
            node.left = addByRecursive(node.left, e);
        } else {
            node.right = addByRecursive(node.right, e);
        }
        return node;
    }

    /**
     * 递归的向node中查找元素e
     * @param node
     * @param e
     */
    public boolean containsByRecursive(Node node, E e){
        if(node == null){
            return false;
        }
        if(e.compareTo((E) node.e) == 0){
            return true;
        }else if(e.compareTo((E) node.e) < 0){
            return containsByRecursive(node.left, e);
        }else{
            return containsByRecursive(node.right, e);
        }
    }
}
```

## 前序遍历
* 先遍历二叉树的根节点 之后再遍历左右子节点（常用）
```
    /**
     * 前序遍历
     */
    public void preOrder(){
        preOrderByRecursive(root);
    }

    /**
     * 递归的前序遍历
     * @param node
     */
    private void preOrderByRecursive(Node node){
        if(node == null){
            return ;
        }
        System.out.println(node.e);
        preOrderByRecursive(node.left);
        preOrderByRecursive(node.right);
    };
```

## 中序遍历
* 先遍历二叉树的所有左子树，之后遍历根节点 再遍历所有右节点
* 二分搜索树的中序遍历结果是顺序的（先左 后中 再右）
```
    /**
     * 中序遍历
     */
    public void inOrder(){
        inOrderByRecursive(root);
    }

    /**
     * 递归的中序遍历
     * @param node
     */
    public void inOrderByRecursive(Node node){
        if(node == null){
            return ;
        }
        inOrderByRecursive(node.left);
        System.out.println(node.e);
        inOrderByRecursive(node.right);
    }
```

## 后序遍历
* 先遍历二叉树的所有左子树，再遍历所有右节点 之后遍历根节点
* 先释放的左右子节点 最后释放根节点
```
    /**
     * 后序遍历
     */
    public void psotOrder(){
        psotOrderByRecursive(root);
    }

    /**
     * 递归的后序遍历
     * @param node
     */
    public void psotOrderByRecursive(Node node){
        if(node == null){
            return ;
        }
        psotOrderByRecursive(node.left);
        psotOrderByRecursive(node.right);
        System.out.println(node.e);
    }
```